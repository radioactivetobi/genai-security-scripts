import openai
import os
import re
import pdfkit
from openai import OpenAI

# Initialize the OpenAI client
client = OpenAI()

# Set your OpenAI API key here
openai.api_key = os.getenv("OPENAI_API_KEY")

def validate_application_details(details):
    """
    Validate that the application details are either a hostname, an IP address, or a binary file name.
    """
    # Regular expressions for validation
    hostname_regex = re.compile(
        r'^(?!-)[A-Z\d-]{1,63}(?<!-)[A-Z\d-]{1,63}(?<!-)\.?$', re.IGNORECASE)
    ip_address_regex = re.compile(
        r'^(\d{1,3}\.){3}\d{1,3}$')
    binary_file_regex = re.compile(
        r'^[a-zA-Z0-9_\-]+(\.[a-zA-Z0-9_\-]+)?$')

    if hostname_regex.match(details) or ip_address_regex.match(details) or binary_file_regex.match(details):
        return True
    else:
        print("Invalid input. Please provide a valid hostname, IP address, or binary file name.")
        return False

def generate_pen_test_finding(vulnerability_type, application_details, application_name, recommendation):
    """
    Generate a penetration test finding based on the provided vulnerability type, application details, and application/organization name.
    """
    # Create the messages for the OpenAI API
    messages = [
        {"role": "system", "content": "You are an experienced penetration tester with 25 years of experience in web, infrastructure, mobile, and API vulnerability assessment and penetration testing."},
        {"role": "user", "content": f"Document a detailed penetration test finding for a '{vulnerability_type}' vulnerability in the following application environment: {application_details} belonging to {application_name}."}
    ]

    # Make the API call
    try:
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=messages,
            max_tokens=2048,
            n=1,
            stop=None,
            temperature=0.7
        )
        
        # Debug: Print out the full response for inspection
        print("API Response:", response)
        
        # Check if the response contains choices and handle appropriately
        if len(response.choices) > 0:
            response_content = response.choices[0].message.content.strip()
            return response_content
        else:
            print("No choices were returned in the API response.")
            return None

    except Exception as e:
        print(f"An error occurred: {e}")
        return None

def save_to_markdown(findings, filename="report.md"):
    """
    Save the generated findings to a Markdown file.
    """
    try:
        with open(filename, "a") as file:
            for finding in findings:
                file.write(finding + "\n\n---\n\n")
        print(f"Findings saved to {filename}")
    except Exception as e:
        print(f"An error occurred while saving the document: {e}")

def save_to_html(findings, filename="report.html"):
    """
    Save the generated findings to an HTML file.
    """
    try:
        with open(filename, "w") as file:
            file.write("<html><body>\n")
            file.write("<h1>Penetration Test Findings</h1>\n")
            for finding in findings:
                # Replace newline characters with <br> for HTML formatting
                formatted_finding = finding.replace('\n', '<br>')
                file.write("<div style='margin-bottom: 20px;'>\n")
                file.write(f"<p>{formatted_finding}</p>\n")
                file.write("<hr>\n")
                file.write("</div>\n")
            file.write("</body></html>\n")
        print(f"Findings saved to {filename}")
    except Exception as e:
        print(f"An error occurred while saving the document: {e}")

def save_to_pdf(findings, filename="report.pdf"):
    """
    Save the generated findings to a PDF file.
    """
    try:
        # First, save the findings as an HTML file
        html_content = "<html><body>\n<h1>Penetration Test Findings</h1>\n"
        for finding in findings:
            formatted_finding = finding.replace('\n', '<br>')
            html_content += "<div style='margin-bottom: 20px;'>\n"
            html_content += f"<p>{formatted_finding}</p>\n"
            html_content += "<hr>\n</div>\n"
        html_content += "</body></html>\n"
        
        with open("temp_report.html", "w") as file:
            file.write(html_content)

        # Convert the HTML file to a PDF
        pdfkit.from_file("temp_report.html", filename)
        print(f"Findings saved to {filename}")
        
        # Optionally, delete the temporary HTML file
        os.remove("temp_report.html")
        
    except Exception as e:
        print(f"An error occurred while saving the PDF: {e}")

# Main logic to gather input and generate multiple findings
findings = []
while True:
    vulnerability_type = input("Enter the vulnerability type (or type 'done' to finish): ")
    if vulnerability_type.lower() == 'done':
        break
    application_details = input("Enter application details (hostname, IP address, or binary file name): ")
    if not validate_application_details(application_details):
        continue
    application_name = input("Enter the application or organization name: ")
    finding = generate_pen_test_finding(vulnerability_type, application_details, application_name, recommendation)
    if finding:
        findings.append(finding)
        print(finding)  # Print the finding as well for immediate feedback

# Prompt the user for the desired output format
output_format = input("Enter the desired output format (html, pdf, md): ").strip().lower()

# Save all findings based on the selected format
if findings:
    if output_format == "html":
        save_to_html(findings)
    elif output_format == "pdf":
        save_to_pdf(findings)
    elif output_format == "md":
        save_to_markdown(findings)
    else:
        print("Invalid output format specified. Please choose between 'html', 'pdf', or 'md'.")
else:
    print("No findings to save.")
